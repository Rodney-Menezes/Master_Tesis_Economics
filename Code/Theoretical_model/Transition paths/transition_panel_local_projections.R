# =============================================================
# Local Projections for Simulated Transition Path Panel
# =============================================================
#
# This script replicates, for the simulated panel generated by the
# theoretical model, the local projection exercises implemented for the
# empirical data in `regressions_firmlevel_dynamiceffect.R`.
#
# Usage:
#   1. Run the MATLAB routine `ANALYZE_transition_path.m` so that the
#      CSV files `mTransitionPanel_*.csv` are generated in this folder.
#   2. Adjust the configuration section below if different horizons or
#      shock profiles are required.
#   3. Execute this script from R (e.g. `Rscript transition_panel_local_projections.R`).
#
# The output consists of tidy data frames with impulse response
# coefficients and (optional) plots saved to disk.
# =============================================================

# ------------------------------
# Load required packages
# ------------------------------
required_pkgs <- c("readr", "dplyr", "purrr", "tidyr", "stringr",
                   "tibble", "fixest", "ggplot2")

missing_pkgs <- required_pkgs[!vapply(required_pkgs, requireNamespace, logical(1), quietly = TRUE)]
if (length(missing_pkgs) > 0) {
  stop(
    sprintf(
      "The following packages are required but not installed: %s",
      paste(missing_pkgs, collapse = ", ")
    ),
    call. = FALSE
  )
}

library(readr)
library(dplyr)
library(purrr)
library(tidyr)
library(stringr)
library(tibble)
library(fixest)
library(ggplot2)

# ------------------------------
# Helper utilities
# ------------------------------
standardize <- function(x) {
  mu <- mean(x, na.rm = TRUE)
  sd_val <- stats::sd(x, na.rm = TRUE)
  if (is.na(sd_val) || sd_val <= sqrt(.Machine$double.eps)) {
    return(rep(0, length(x)))
  }
  (x - mu) / sd_val
}

add_cum_future_sums <- function(df, var, horizons, id_var = "firm_id", time_var = "quarter_id") {
  stopifnot(var %in% names(df))
  df %>%
    dplyr::group_by(.data[[id_var]]) %>%
    dplyr::arrange(.data[[time_var]], .by_group = TRUE) %>%
    dplyr::group_modify(~ {
      tmp <- .x
      for (h in horizons) {
        lead_cols <- purrr::map_dfc(0:h, ~ dplyr::lead(tmp[[var]], .x))
        tmp[[paste0("cumF", h, "_", var)]] <- rowSums(lead_cols, na.rm = TRUE)
      }
      tmp
    }) %>%
    dplyr::ungroup()
}

run_local_projection <- function(df, horizons, shock_var, controls, fe = c("firm_id", "quarter_id"),
                                 cluster = "firm_id", dep_var_prefix = "cumF", dep_var_suffix = "_dlog_capital") {
  if (!shock_var %in% names(df)) {
    stop(sprintf("Variable '%s' not found in data frame.", shock_var))
  }
  
  regressors <- c(shock_var, controls)
  regressors <- regressors[regressors %in% names(df)]
  if (!shock_var %in% regressors) {
    stop(sprintf("Shock variable '%s' is not available after dropping missing controls.", shock_var))
  }
  
  cluster_formula <- NULL
  if (!is.null(cluster)) {
    cluster_formula <- stats::as.formula(paste0("~", paste(cluster, collapse = " + ")))
  }
  
  purrr::map_dfr(horizons, function(h) {
    dep_var <- paste0(dep_var_prefix, h, dep_var_suffix)
    if (!dep_var %in% names(df)) {
      stop(sprintf("Dependent variable '%s' not found. Did you compute cumulative sums?", dep_var))
    }
    
    rhs <- paste(regressors, collapse = " + ")
    fe_part <- paste(fe, collapse = " + ")
    fml <- stats::as.formula(paste0(dep_var, " ~ ", rhs, " | ", fe_part))
    
    est <- fixest::feols(fml, data = df, cluster = cluster_formula)
    
    if (!shock_var %in% names(coef(est))) {
      tibble(
        horizon = h,
        term = shock_var,
        estimate = NA_real_,
        std_error = NA_real_,
        statistic = NA_real_,
        p_value = NA_real_,
        conf_low = NA_real_,
        conf_high = NA_real_,
        n_obs = stats::nobs(est)
      )
    } else {
      vc <- fixest::vcov(est)
      se <- sqrt(vc[shock_var, shock_var])
      beta <- coef(est)[shock_var]
      tibble(
        horizon = h,
        term = shock_var,
        estimate = beta,
        std_error = se,
        statistic = beta / se,
        p_value = 2 * stats::pnorm(-abs(beta / se)),
        conf_low = beta - 1.645 * se,
        conf_high = beta + 1.645 * se,
        n_obs = stats::nobs(est)
      )
    }
  })
}

# ------------------------------
# Configuration
# ------------------------------
panel_pattern <- "mTransitionPanel_\\d+\\.csv"
shock_length <- 12
shock_size <- 0.0025
shock_decay <- 0.5
shock_multiplier <- 4
pre_sample_drop <- 4
horizons <- 0:12
output_dir <- "../Results/panel_simulations"
plot_results <- TRUE

if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
}

# ------------------------------
# Load available panel files
# ------------------------------
panel_files <- list.files(pattern = panel_pattern, full.names = TRUE)
if (length(panel_files) == 0) {
  stop("No panel files found. Run the MATLAB routine to generate 'mTransitionPanel_*.csv'.")
}

message(sprintf("Found %d panel file(s).", length(panel_files)))

# ------------------------------
# Process each panel and run projections
# ------------------------------
all_results <- purrr::map(panel_files, function(file_path) {
  file_name <- basename(file_path)
  t_pre <- as.integer(stringr::str_match(file_name, "mTransitionPanel_(\\d+)\\.csv")[, 2])
  if (is.na(t_pre)) {
    stop(sprintf("Cannot parse tPre from file name '%s'.", file_name))
  }
  
  message(sprintf("Processing %s (tPre = %d)...", file_name, t_pre))
  
  df_raw <- readr::read_csv(
    file_path,
    col_names = FALSE,
    show_col_types = FALSE,
    progress = FALSE
  )
  
  colnames(df_raw) <- c(
    "firm_id", "quarter_id", "in_sample", "balanced_panel", "investment", "cash_flow",
    "market_value", "capital", "cash", "debt", "employment", "interest_rate", "unconstrained"
  )
  
  df <- df_raw %>%
    dplyr::filter(in_sample == 1) %>%
    dplyr::arrange(firm_id, quarter_id) %>%
    dplyr::group_by(firm_id) %>%
    dplyr::mutate(
      log_capital = log(capital),
      lag_log_capital = dplyr::lag(log_capital),
      dlog_capital = log_capital - lag_log_capital,
      cf_k = dplyr::if_else(capital > 0, cash_flow / capital, NA_real_),
      debt_lead = dplyr::lead(debt),
      capital_lead = dplyr::lead(capital),
      lev = debt_lead / capital_lead,
      lev = dplyr::if_else(lev < 0 & !is.na(lev), debt_lead / (capital_lead - debt_lead), lev),
      lev_gross = dplyr::if_else(!is.na(lev) & lev > 0, lev, 0),
      mean_lev = mean(lev, na.rm = TRUE),
      mean_lev_gross = mean(lev_gross, na.rm = TRUE),
      lev_within = lev - mean_lev,
      lev_within_gross = lev_gross - mean_lev_gross
    ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(
      lev_within_std = standardize(lev_within),
      lev_within_std_gross = standardize(lev_within_gross)
    ) %>%
    dplyr::group_by(firm_id) %>%
    dplyr::arrange(quarter_id, .by_group = TRUE) %>%
    dplyr::mutate(
      L1_lev_within = dplyr::lag(lev_within),
      L1_lev_within_gross = dplyr::lag(lev_within_gross),
      L1_lev_within_std = dplyr::lag(lev_within_std),
      L1_lev_within_std_gross = dplyr::lag(lev_within_std_gross),
      L1_cf_k = dplyr::lag(cf_k),
      L1_log_capital = dplyr::lag(log_capital)
    ) %>%
    dplyr::ungroup()
  
  shock_profile <- tibble::tibble(
    quarter_id = t_pre + seq_len(shock_length),
    epsilon_m = -shock_size * (shock_decay ^ (seq_len(shock_length) - 1))
  )
  
  df <- df %>%
    dplyr::left_join(shock_profile, by = "quarter_id") %>%
    dplyr::mutate(
      epsilon_m = dplyr::if_else(is.na(epsilon_m), 0, epsilon_m),
      epsilon_m = -shock_multiplier * epsilon_m,
      shock_exp = epsilon_m,
      lev_shock_within = L1_lev_within * epsilon_m,
      lev_shock_within_gross = L1_lev_within_gross * epsilon_m,
      lev_shock_within_std = L1_lev_within_std * epsilon_m,
      lev_shock_within_gross_std = L1_lev_within_std_gross * epsilon_m
    ) %>%
    dplyr::filter(quarter_id > (t_pre - pre_sample_drop))
  
  df <- add_cum_future_sums(df, "dlog_capital", horizons)
  
  lp_controls <- c("L1_lev_within_gross", "L1_cf_k", "L1_log_capital")
  
  lp_results <- run_local_projection(
    df = df,
    horizons = horizons,
    shock_var = "lev_shock_within_gross",
    controls = lp_controls,
    cluster = "firm_id"
  ) %>%
    dplyr::mutate(sample_tpre = t_pre, specification = "gross")
  
  lp_results_std <- run_local_projection(
    df = df,
    horizons = horizons,
    shock_var = "lev_shock_within_gross_std",
    controls = c("L1_lev_within_std_gross", "L1_cf_k", "L1_log_capital"),
    cluster = "firm_id"
  ) %>%
    dplyr::mutate(sample_tpre = t_pre, specification = "gross_std")
  
  tibble::lst(data = df, results = dplyr::bind_rows(lp_results, lp_results_std))
})

results_tbl <- purrr::map_dfr(all_results, "results")

# ------------------------------
# Save outputs
# ------------------------------
readr::write_csv(results_tbl, file.path(output_dir, "local_projection_coefficients.csv"))
message(sprintf("Saved coefficient table to %s", file.path(output_dir, "local_projection_coefficients.csv")))

if (plot_results) {
  plot_obj <- results_tbl %>%
    dplyr::mutate(sample_label = paste0("tPre = ", sample_tpre)) %>%
    ggplot(aes(x = horizon, y = estimate, colour = specification, fill = specification)) +
    geom_line(size = 1) +
    geom_point(size = 2) +
    geom_ribbon(aes(ymin = conf_low, ymax = conf_high), alpha = 0.2, colour = NA) +
    facet_wrap(~ sample_label, ncol = 2) +
    scale_x_continuous(breaks = horizons) +
    labs(
      title = "Local Projections: Simulated Panel",
      x = "Horizonte (trimestres)",
      y = "Efecto acumulado en Δlog(K)",
      colour = "Especificación",
      fill = "Especificación"
    ) +
    theme_minimal()
  
  ggsave(
    filename = file.path(output_dir, "local_projection_responses.png"),
    plot = plot_obj,
    width = 10,
    height = max(6, ceiling(length(unique(results_tbl$sample_tpre)) / 2) * 3)
  )
  message(sprintf("Saved plots to %s", file.path(output_dir, "local_projection_responses.png")))
}

# Display a compact preview in the console
print(head(results_tbl, 12))

message("Local projection analysis completed.")