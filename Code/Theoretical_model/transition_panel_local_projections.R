# =============================================================
# Local Projections for Simulated Transition Path Panel
# =============================================================
#
# This script replicates, for the simulated panel generated by the
# theoretical model, the empirical workflow implemented in
# `regressions_firmlevel_dynamiceffect.R`. The goal is to align the
# construction of variables, interactions, and local projections so that
# the simulated responses can be compared directly with the empirical
# estimates.
#
# Usage:
#   1. Run the MATLAB routine `ANALYZE_transition_path.m` so that the CSV
#      files `mTransitionPanel_*.csv` are generated in this folder.
#   2. Adjust the configuration section below if different horizons or
#      shock profiles are required.
#   3. Execute this script from R (e.g. `Rscript transition_panel_local_projections.R`).
#
# The output consists of tidy data frames with impulse-response
# coefficients plus (optional) plots saved to disk. The organisation of
# the code mirrors the empirical script so that future changes can be
# ported easily between the two environments.
# =============================================================

# ------------------------------
# Load required packages
# ------------------------------
required_pkgs <- c(
  "readr", "dplyr", "purrr", "tidyr", "stringr", "tibble",
  "fixest", "ggplot2", "rlang", "patchwork"
)

missing_pkgs <- required_pkgs[!vapply(required_pkgs, requireNamespace, logical(1), quietly = TRUE)]
if (length(missing_pkgs) > 0) {
  stop(
    sprintf(
      "The following packages are required but not installed: %s",
      paste(missing_pkgs, collapse = ", ")
    ),
    call. = FALSE
  )
}

library(readr)
library(dplyr)
library(purrr)
library(tidyr)
library(stringr)
library(tibble)
library(fixest)
library(ggplot2)
library(rlang)
library(patchwork)

options(fixest_notes = FALSE)

# ------------------------------
# Helper utilities
# ------------------------------
detect_script_dir <- function() {
  cmd_args <- commandArgs(trailingOnly = FALSE)
  file_arg <- "--file="
  file_index <- grep(file_arg, cmd_args)
  if (length(file_index) > 0) {
    script_path <- sub(file_arg, "", cmd_args[file_index[1]])
    return(dirname(normalizePath(script_path)))
  }

  ofile <- tryCatch(sys.frames()[[1]]$ofile, error = function(e) NULL)
  if (!is.null(ofile)) {
    return(dirname(normalizePath(ofile)))
  }

  normalizePath(getwd())
}

winsorize <- function(x, p = 0.005) {
  if (all(is.na(x))) {
    return(x)
  }
  lo <- stats::quantile(x, p, na.rm = TRUE, names = FALSE, type = 7)
  hi <- stats::quantile(x, 1 - p, na.rm = TRUE, names = FALSE, type = 7)
  x <- pmin(pmax(x, lo), hi)
  x
}

prep_fin_vars <- function(df, p = 0.005, country_var = "Country", firm_var = "name") {
  stopifnot(all(c("leverage", "dd") %in% names(df)))

  df <- df %>%
    dplyr::ungroup() %>%
    dplyr::group_by(.data[[country_var]]) %>%
    dplyr::mutate(
      leverage_win = winsorize(leverage, p = p),
      dd_win = winsorize(dd, p = p)
    ) %>%
    dplyr::ungroup()
  
  lev_panel_mean <- mean(df$leverage_win, na.rm = TRUE)
  dd_panel_mean <- mean(df$dd_win, na.rm = TRUE)
  
  if (is.na(lev_panel_mean)) {
    lev_panel_mean <- 0
  }
  if (is.na(dd_panel_mean)) {
    dd_panel_mean <- 0
  }
  
  df %>%
    dplyr::group_by(.data[[firm_var]]) %>%
    dplyr::arrange(dateq, .by_group = TRUE) %>%
    dplyr::mutate(
      lev_dm = leverage_win - mean(leverage_win, na.rm = TRUE),
      dd_dm = dd_win - mean(dd_win, na.rm = TRUE),
      lev_bw = leverage_win - lev_panel_mean,
      dd_bw = dd_win - dd_panel_mean,
      L1_lev_dm = dplyr::lag(lev_dm, 1),
      L1_dd_dm = dplyr::lag(dd_dm, 1),
      L1_lev_bw = dplyr::lag(lev_bw, 1),
      L1_dd_bw = dplyr::lag(dd_bw, 1),
      L1_leverage_win = dplyr::lag(leverage_win, 1),
      L1_dd_win = dplyr::lag(dd_win, 1)
    ) %>%
    dplyr::ungroup()
}

select_heterogeneity_term <- function(df, candidates, min_sd = 1e-08, verbose = TRUE) {
  available <- intersect(candidates, names(df))
  if (length(available) == 0) {
    stop(sprintf(
      "None of the candidate heterogeneity terms are present in the data: %s",
      paste(candidates, collapse = ", ")
    ))
  }
  
  primary <- available[1]
  for (col in available) {
    sd_val <- stats::sd(df[[col]], na.rm = TRUE)
    if (!is.na(sd_val) && sd_val > min_sd) {
      if (verbose && col != primary) {
        message(sprintf("Using '%s' as heterogeneity term instead of '%s'.", col, primary))
      }
      return(df[[col]])
    }
  }
  
  if (verbose) {
    warning(sprintf(
      "All candidate heterogeneity variables have near-zero variation: %s",
      paste(available, collapse = ", ")
    ))
  }
  
  df[[primary]]
}

prep_shock_var <- function(df, shock_col = "shock", p = 0.005, country_var = "Country") {
  stopifnot(shock_col %in% names(df))

  shock_sym <- rlang::sym(shock_col)

  df %>%
    dplyr::ungroup() %>%
    dplyr::group_by(.data[[country_var]]) %>%
    dplyr::mutate(
      shock_win = winsorize(!!shock_sym, p = p),
      shock_exp = -shock_win
    ) %>%
    dplyr::ungroup()
}

prep_ctrl_var <- function(df, var_in, prefix = var_in, p = 0.005, country_var = "Country") {
  stopifnot(var_in %in% names(df))

  win_sym <- rlang::sym(paste0(prefix, "_win"))
  var_sym <- rlang::sym(var_in)

  df %>%
    dplyr::ungroup() %>%
    dplyr::group_by(.data[[country_var]]) %>%
    dplyr::mutate(
      !!win_sym := winsorize(!!var_sym, p = p)
    ) %>%
    dplyr::ungroup()
}

add_lagged_controls <- function(df, vars, lag = 1, firm_var = "name") {
  vars_present <- intersect(vars, names(df))
  if (length(vars_present) == 0) {
    return(df)
  }

  lag_prefix <- paste0("L", lag, "_")

  df %>%
    dplyr::group_by(.data[[firm_var]]) %>%
    dplyr::arrange(dateq, .by_group = TRUE) %>%
    dplyr::mutate(dplyr::across(
      dplyr::all_of(vars_present),
      ~ dplyr::lag(.x, lag),
      .names = paste0(lag_prefix, "{.col}")
    )) %>%
    dplyr::ungroup()
}

build_cum_future_sums <- function(df, var, horizons, id_var = "name", time_var = "dateq") {
  stopifnot(var %in% names(df))

  df %>%
    dplyr::group_by(.data[[id_var]]) %>%
    dplyr::arrange(.data[[time_var]], .by_group = TRUE) %>%
    dplyr::group_modify(~ {
      tmp <- .x
      for (h in horizons) {
        lead_cols <- purrr::map_dfc(0:h, ~ dplyr::lead(tmp[[var]], .x))
        tmp[[paste0("cumF", h, "_", var)]] <- rowSums(lead_cols, na.rm = TRUE)
      }
      tmp
    }) %>%
    dplyr::ungroup()
}

run_lp_series <- function(df,
                          horizons = NULL,
                          shock_term,
                          controls = character(),
                          fe_terms = c("name", "sec", "dateq"),
                          cluster_terms = c("Country", "dateq", "name"),
                          dep_var_prefix = "cumF",
                          dep_var_suffix = "_dlog_capital",
                          specification,
                          sample_tpre) {
  if (is.null(horizons)) {
    horizon_pattern <- paste0("^", dep_var_prefix, "(\\d+)", dep_var_suffix, "$")
    horizon_matches <- stringr::str_match(names(df), horizon_pattern)
    valid_matches <- !is.na(horizon_matches[, 2])
    
    if (!any(valid_matches)) {
      stop(
        sprintf(
          paste0(
            "Unable to infer horizons automatically. ",
            "Ensure columns following the pattern '%s{h}%s' exist or provide `horizons`."
          ),
          dep_var_prefix,
          dep_var_suffix
        ),
        call. = FALSE
      )
    }
    
    horizons <- sort(unique(as.integer(horizon_matches[valid_matches, 2])))
  }

  fe_avail <- intersect(fe_terms, names(df))
  fe_string <- if (length(fe_avail) == 0) {
    "0"
  } else {
    paste(fe_avail, collapse = " + ")
  }

  cluster_avail <- intersect(cluster_terms, names(df))
  cluster_formula <- if (length(cluster_avail) == 0) {
    NULL
  } else {
    stats::as.formula(paste0("~", paste(cluster_avail, collapse = " + ")))
  }

  avail_controls <- intersect(controls, names(df))
  regressors <- unique(c(shock_term, avail_controls))
  if (!shock_term %in% regressors) {
    stop(sprintf("Shock variable '%s' is not available in the data frame.", shock_term))
  }

  crit_val <- 1.645

  purrr::map_dfr(horizons, function(h) {
    dep_var <- paste0(dep_var_prefix, h, dep_var_suffix)
    if (!dep_var %in% names(df)) {
      stop(sprintf("Dependent variable '%s' not found. Did you compute cumulative sums?", dep_var))
    }
  
    rhs <- paste(regressors, collapse = " + ")
    fml <- stats::as.formula(paste0(dep_var, " ~ ", rhs, " | ", fe_string))

    est <- tryCatch(
      fixest::feols(fml, data = df, cluster = cluster_formula),
      error = function(e) {
        warning(sprintf(
          "Local projection failed to converge for horizon %d in spec '%s': %s",
          h,
          specification,
          conditionMessage(e)
        ))
        NULL
      }
    )

    if (is.null(est)) {
      tibble(
        horizon = h,
        term = shock_term,
        estimate = NA_real_,
        std_error = NA_real_,
        statistic = NA_real_,
        p_value = NA_real_,
        conf_low = NA_real_,
        conf_high = NA_real_,
        n_obs = NA_integer_,
        specification = specification,
        sample_tpre = sample_tpre
      )
    } else if (!shock_term %in% names(coef(est))) {
      warning(sprintf(
        "The term '%s' was dropped due to collinearity at horizon %d in spec '%s'.",
        shock_term,
        h,
        specification
      ))
      tibble(
        horizon = h,
        term = shock_term,
        estimate = NA_real_,
        std_error = NA_real_,
        statistic = NA_real_,
        p_value = NA_real_,
        conf_low = NA_real_,
        conf_high = NA_real_,
        n_obs = stats::nobs(est),
        specification = specification,
        sample_tpre = sample_tpre
      )
    } else {
      vc <- fixest::vcov(est)
      se <- sqrt(vc[shock_term, shock_term])
      beta <- coef(est)[shock_term]
      tibble(
        horizon = h,
        term = shock_term,
        estimate = beta,
        std_error = se,
        statistic = beta / se,
        p_value = 2 * stats::pnorm(-abs(beta / se)),
        conf_low = beta - crit_val * se,
        conf_high = beta + crit_val * se,
        n_obs = stats::nobs(est),
        specification = specification,
        sample_tpre = sample_tpre
      )
    }
  })
}

make_irf_plot <- function(res_tbl, spec, colour, title, horizons, y_label = "Efecto acumulado en Δlog(K)") {
  df_plot <- res_tbl %>%
    dplyr::filter(specification == spec) %>%
    dplyr::arrange(horizon)

  if (nrow(df_plot) == 0 || all(is.na(df_plot$estimate))) {
    return(NULL)
  }

  ggplot(df_plot, aes(x = horizon, y = estimate)) +
    geom_line(size = 1, colour = colour) +
    geom_point(size = 2, colour = colour) +
    geom_ribbon(
      aes(ymin = conf_low, ymax = conf_high),
      alpha = 0.2,
      fill = colour,
      colour = NA
    ) +
    scale_x_continuous(breaks = horizons) +
    labs(
      title = title,
      x = "Trimestres",
      y = y_label
    ) +
    theme_minimal()
}

# ------------------------------
# Configuration
# ------------------------------
panel_pattern <- "mTransitionPanel_\\d+\\.csv"
shock_length <- 12
shock_size <- 0.0025
shock_decay <- 0.5
shock_multiplier <- 4
pre_sample_drop <- 4
horizons <- 0:12
winsor_prob <- 0.005
sector_groups <- 3

script_dir <- detect_script_dir()
panel_dir <- Sys.getenv("TRANSITION_PANEL_DIR", unset = NA_character_)
if (is.na(panel_dir) || !nzchar(panel_dir)) {
  panel_dir <- script_dir
} else {
  panel_dir <- normalizePath(panel_dir)
}

output_dir <- Sys.getenv("TRANSITION_OUTPUT_DIR", unset = NA_character_)
if (is.na(output_dir) || !nzchar(output_dir)) {
  output_dir <- file.path(script_dir, "..", "Results", "panel_simulations")
}
output_dir <- normalizePath(output_dir, mustWork = FALSE)
plot_results <- TRUE

if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
}

# ------------------------------
# Load available panel files
# ------------------------------
message(sprintf("Searching for panel files in: %s", panel_dir))
panel_files <- list.files(path = panel_dir, pattern = panel_pattern, full.names = TRUE)
if (length(panel_files) == 0) {
  panel_files <- list.files(path = panel_dir, pattern = panel_pattern, full.names = TRUE, recursive = TRUE)
}
panel_files <- unique(panel_files)
if (length(panel_files) == 0) {
  stop("No panel files found. Run the MATLAB routine to generate 'mTransitionPanel_*.csv'.")
}

message(sprintf("Found %d panel file(s).", length(panel_files)))

# ------------------------------
# Process each panel and run projections
# ------------------------------
all_results <- purrr::map(panel_files, function(file_path) {
  file_name <- basename(file_path)
  t_pre <- as.integer(stringr::str_match(file_name, "mTransitionPanel_(\\d+)\\.csv")[, 2])
  if (is.na(t_pre)) {
    stop(sprintf("Cannot parse tPre from file name '%s'.", file_name))
  }

  message(sprintf("Processing %s (tPre = %d)...", file_name, t_pre))

  df_raw <- readr::read_csv(
    file_path,
    col_names = FALSE,
    show_col_types = FALSE,
    progress = FALSE
  )

  colnames(df_raw) <- c(
    "firm_id", "quarter_id", "in_sample", "balanced_panel", "investment", "cash_flow",
    "market_value", "capital", "cash", "debt", "employment", "interest_rate", "unconstrained"
  )

  df_panel <- df_raw %>%
    dplyr::filter(in_sample == 1) %>%
    dplyr::mutate(
      Country = "Model",
      name = paste0("firm_", firm_id),
      dateq = quarter_id,
      sec = paste0("sector_", (as.integer(factor(firm_id)) - 1L) %% sector_groups + 1L)
    ) %>%
    dplyr::arrange(name, dateq)

  df_panel <- df_panel %>%
    dplyr::group_by(name) %>%
    dplyr::arrange(dateq, .by_group = TRUE) %>%
    dplyr::mutate(
      capital = dplyr::if_else(capital > 0, capital, NA_real_),
      log_capital = log(capital),
      L1_log_capital = dplyr::lag(log_capital, 1),
      dlog_capital = log_capital - L1_log_capital,
      investment_rate = dplyr::if_else(capital > 0, investment / capital, NA_real_),
      cf_k = dplyr::if_else(capital > 0, cash_flow / capital, NA_real_),
      cash_ratio = dplyr::if_else(capital > 0, cash / capital, NA_real_),
      debt_ratio = dplyr::if_else(capital > 0, debt / capital, NA_real_),
      leverage = debt_ratio,
      dd = 1 - debt_ratio,
      Ldl_capital = dplyr::lag(dlog_capital, 1)
    ) %>%
    dplyr::ungroup() %>%
    dplyr::filter(!is.na(dlog_capital))

  shock_profile <- tibble::tibble(
    dateq = t_pre + seq_len(shock_length),
    epsilon_m = -shock_size * (shock_decay ^ (seq_len(shock_length) - 1))
  )

  df_panel <- df_panel %>%
    dplyr::left_join(shock_profile, by = "dateq") %>%
    dplyr::mutate(
      epsilon_m = dplyr::if_else(is.na(epsilon_m), 0, epsilon_m),
      shock = shock_multiplier * epsilon_m
    ) %>%
    dplyr::filter(dateq > (t_pre - pre_sample_drop))

  df_panel <- df_panel %>%
    prep_shock_var(shock_col = "shock", p = winsor_prob) %>%
    prep_fin_vars(p = winsor_prob) %>%
    prep_ctrl_var(var_in = "investment_rate", prefix = "investment_rate", p = winsor_prob) %>%
    prep_ctrl_var(var_in = "cf_k", prefix = "cf_k", p = winsor_prob) %>%
    prep_ctrl_var(var_in = "cash_ratio", prefix = "cash_ratio", p = winsor_prob) %>%
    add_lagged_controls(c("investment_rate_win", "cf_k_win", "cash_ratio_win"))
  
  lev_term <- select_heterogeneity_term(
    df_panel,
    candidates = c("L1_lev_dm", "L1_lev_bw", "L1_leverage_win")
  )
  dd_term <- select_heterogeneity_term(
    df_panel,
    candidates = c("L1_dd_dm", "L1_dd_bw", "L1_dd_win")
  )
  
  df_panel <- df_panel %>%
    dplyr::mutate(
      lev_interaction = lev_term,
      d2d_interaction = dd_term,
      lev_shock = lev_interaction * shock_exp,
      d2d_shock = d2d_interaction * shock_exp
    )

  df_panel <- build_cum_future_sums(df_panel, "dlog_capital", horizons)

  controls_firm <- c("L1_investment_rate_win", "L1_cf_k_win", "L1_cash_ratio_win", "L1_log_capital")
  controls_macro <- intersect(c("dlog_gdp", "dlog_cpi", "unemp", "embigl"), names(df_panel))
  controls_vec_nocy <- c(controls_firm, controls_macro)

  res_lev_nocy <- run_lp_series(
    df = df_panel,
    horizons = horizons,
    shock_term = "lev_shock",
    controls = controls_vec_nocy,
    specification = "hetero_leverage",
    sample_tpre = t_pre
  )

  res_dd_nocy <- run_lp_series(
    df = df_panel,
    horizons = horizons,
    shock_term = "d2d_shock",
    controls = controls_vec_nocy,
    specification = "hetero_distance",
    sample_tpre = t_pre
  )

  res_avg <- run_lp_series(
    df = df_panel,
    horizons = horizons,
    shock_term = "shock_exp",
    controls = c("lev_shock", "d2d_shock", controls_vec_nocy),
    specification = "avg_baseline",
    sample_tpre = t_pre
  )

  res_avg_lag <- run_lp_series(
    df = df_panel,
    horizons = horizons,
    shock_term = "shock_exp",
    controls = c("lev_shock", "d2d_shock", "Ldl_capital", controls_vec_nocy),
    specification = "avg_withlag",
    sample_tpre = t_pre
  )

  tibble::lst(
    data = df_panel,
    results = dplyr::bind_rows(res_lev_nocy, res_dd_nocy, res_avg, res_avg_lag),
    panel_label = file_name
  )
})

results_tbl <- purrr::map_dfr(all_results, "results")

# ------------------------------
# Save outputs
# ------------------------------
output_file <- file.path(output_dir, "local_projection_coefficients.csv")
readr::write_csv(results_tbl, output_file)
message(sprintf("Saved coefficient table to %s", output_file))

if (plot_results) {
  unique_samples <- sort(unique(results_tbl$sample_tpre))
  purrr::walk(unique_samples, function(t_pre) {
    sample_results <- results_tbl %>%
      dplyr::filter(sample_tpre == t_pre)

    p_lev <- make_irf_plot(
      sample_results,
      spec = "hetero_leverage",
      colour = "firebrick",
      title = "Panel (a): Heterogeneidad por apalancamiento",
      horizons = horizons
    )

    p_dd <- make_irf_plot(
      sample_results,
      spec = "hetero_distance",
      colour = "steelblue",
      title = "Panel (b): Heterogeneidad por distancia al default",
      horizons = horizons
    )

    if (!is.null(p_lev) || !is.null(p_dd)) {
      if (!requireNamespace("patchwork", quietly = TRUE)) {
        warning("Package 'patchwork' not available; skipping Figure 1 plot.")
      } else {
        plot_obj <- patchwork::wrap_plots(list(p_lev, p_dd), ncol = 2)
        fig1_path <- file.path(output_dir, sprintf("figure1_hetero_tpre%d.png", t_pre))
        ggplot2::ggsave(fig1_path, plot = plot_obj, width = 10, height = 5, dpi = 300)
        message(sprintf("Saved heterogeneity plot to %s", fig1_path))
      }
    }

    p_avg <- make_irf_plot(
      sample_results,
      spec = "avg_baseline",
      colour = "darkgreen",
      title = "Figura 2: Respuesta Dinámica de la Inversión ante un Shock Monetario",
      horizons = horizons
    )

    if (!is.null(p_avg)) {
      fig2_path <- file.path(output_dir, sprintf("figure2_avg_tpre%d.png", t_pre))
      ggplot2::ggsave(fig2_path, plot = p_avg, width = 7, height = 5, dpi = 300)
      message(sprintf("Saved average-response plot to %s", fig2_path))
    }

    p_avg_lag <- make_irf_plot(
      sample_results,
      spec = "avg_withlag",
      colour = "purple",
      title = "Figura 4: Respuesta Dinámica residual ante un Shock Monetario",
      horizons = horizons,
      y_label = "Efecto acumulado en Δlog(K) residual"
    )

    if (!is.null(p_avg_lag)) {
      fig4_path <- file.path(output_dir, sprintf("figure4_avg_withlag_tpre%d.png", t_pre))
      ggplot2::ggsave(fig4_path, plot = p_avg_lag, width = 7, height = 5, dpi = 300)
      message(sprintf("Saved residual-response plot to %s", fig4_path))
    }
  })
}

# Display a compact preview in the console
print(head(results_tbl, 12))

message("Local projection analysis completed.")